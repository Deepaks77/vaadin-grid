<!--
@license
Copyright (c) 2019 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<script>
  window.Vaadin = window.Vaadin || {};
  window.Vaadin.Grid = window.Vaadin.Grid || {};

  /**
   * @polymerMixin
   */
  Vaadin.Grid.DragAndDropMixin = superClass => class DragAndDropMixin extends superClass {

    static get properties() {
      // TODO: Consider string props with options instead of boolean values
      return {
        dragSingleRows: Boolean,

        dropBetweenRows: Boolean,

        _dragImage: {
          value: () => new Image()
        }

      };
    }

    static get observers() {
      return [
        '_generateDragImage(selectedItems)'
      ]
    }

    _generateDragImage(selectedItems) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.font = '20px Arial';
      ctx.fillText(selectedItems.length || 1, 10, 50);
      this._dragImage.src = canvas.toDataURL();
      this._rowDragGhost.textContent = selectedItems.length || 1;
    }

    get _rowDragGhost() {
      return this.shadowRoot.querySelector('[part~="row-drag-ghost"]');
    }

    ready() {
      super.ready();
      this.$.table.addEventListener('dragstart', this._onDragStart.bind(this));
      this.$.table.addEventListener('dragend', this._onDragEnd.bind(this));
      this.addEventListener('dragover', this._onDragOver.bind(this));
      this.$.table.addEventListener('dragleave', this._clearDragStyles.bind(this));
      this.$.table.addEventListener('drop', this._onDrop.bind(this));
    }

    _onDragStart(e) {
      e.stopPropagation();
      this._toggleAttribute('dragging-rows', true, this);

      const item = this.getEventContext(e).item || this.__getRowModel(e.target).item;

      if (!window.ShadyDOM) {
        const row = Array.from(this.$.items.children).find(row => row._item === item);
        // Safari doesn't get proper drag images from transformed
        // elements so we need to switch to top temporarily
        const transform = row.style.transform;
        row.style.top = /translateY\((.*)\)/.exec(transform)[1];
        row.style.transform = 'none';

        e.dataTransfer.setDragImage(row, 0, 0);

        requestAnimationFrame(() => {
          row.style.top = '';
          row.style.transform = transform;
        });
      }

      // Get dataTransfer text data
      const items = this._isSelected(item) ? this.selectedItems.slice(0) : [item];
      e.dataTransfer.setData('text', this.formatDragData(items));

      const dropEvent = new CustomEvent('grid-dragstart', {
        bubbles: e.bubbles,
        cancelable: e.cancelable,
        detail: {
          items
        }
      });
      this.dispatchEvent(dropEvent);
    }

    _onDragEnd(e) {
      this._toggleAttribute('dragging-rows', false, this);
      e.stopPropagation();
      e.dataTransfer.setDragImage(this._dragImage, 10, 10);
      const item = this.getEventContext(e).item;

      const items = this._isSelected(item) ? this.selectedItems.slice(0) : [item];

      e.dataTransfer.setData('text', this.formatDragData(items));
      // this.$.items.style.height = '100px';
      // this.$.items.style.overflow = 'hidden';

      // setTimeout(() => {
      //   this.$.items.style.height = '';
      // this.$.items.style.overflow = '';
      // })

      const dropEvent = new CustomEvent('grid-dragstart', {
        bubbles: e.bubbles,
        cancelable: e.cancelable,
        detail: {
          items
        }
      });
      this.dispatchEvent(dropEvent);
    }

    _onDragOver(e) {
      if (this.dropBetweenRows) {

        let row = e.composedPath().filter(node => node.localName === 'tr')[0];
        if (!row || row.parentNode !== this.$.items) {
          return;
        }

        this._dragOverItem = row._item;

        e.preventDefault();

        const rowRect = row.getBoundingClientRect();
        const dropAbove = e.clientY - rowRect.top < rowRect.bottom - e.clientY;
        this._dragOverPosition = dropAbove ? 'above' : 'below';

        if (!row.hasAttribute('row-drag-above') && !row.hasAttribute('row-drag-above')) {
          this._clearDragStyles();
        }
        this._toggleAttribute('row-drag-above', dropAbove, row);
        this._toggleAttribute('row-drag-below', !dropAbove, row);

      }
    }

    _clearDragStyles() {
      Array.from(this.$.items.children).forEach(row => {
        this._toggleAttribute('row-drag-above', false, row);
        this._toggleAttribute('row-drag-below', false, row);
      });
    }

    _onDrop(e) {
      e.stopPropagation();
      const data = e.dataTransfer.getData('text');
      this._clearDragStyles();

      const dropEvent = new CustomEvent('grid-drop', {
        bubbles: e.bubbles,
        cancelable: e.cancelable,
        detail: {
          item: this._dragOverItem,
          position: this._dragOverPosition,
          data
        }
      });
      this.dispatchEvent(dropEvent);
    }

    formatDragData(items) {
      return items.map(item => {
        return this._columnTree.slice(0).pop()
          .sort((a, b) => a._order > b._order ? 1 : -1)
          .filter(col => col.path)
          .map(col => this.get(col.path, item))
          .join('\t');
      }).join('\n');
    }

    _updateItem(row, item) {
      super._updateItem && super._updateItem(row, item);

      const draggableElements = window.ShadyDOM
        ? [row]
        : Array.from(row.children).map(cell => cell._content);

      draggableElements.forEach(e => {
        if (this.dragSingleRows) {
          e.setAttribute('draggable', true);
        } else {
          e.removeAttribute('draggable');
        }
      });
    }

  };
</script>
